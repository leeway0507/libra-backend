// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: select.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const extractBooksForEmbedding = `-- name: ExtractBooksForEmbedding :many
SELECT
    isbn,
    title,
    description,
    toc,
    recommendation
FROM books b
WHERE (
        b.vector_search is false
        and b.source is not null
    )
`

type ExtractBooksForEmbeddingRow struct {
	Isbn           pgtype.Text `json:"isbn"`
	Title          pgtype.Text `json:"title"`
	Description    pgtype.Text `json:"description"`
	Toc            pgtype.Text `json:"toc"`
	Recommendation pgtype.Text `json:"recommendation"`
}

func (q *Queries) ExtractBooksForEmbedding(ctx context.Context) ([]ExtractBooksForEmbeddingRow, error) {
	rows, err := q.db.Query(ctx, extractBooksForEmbedding)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtractBooksForEmbeddingRow
	for rows.Next() {
		var i ExtractBooksForEmbeddingRow
		if err := rows.Scan(
			&i.Isbn,
			&i.Title,
			&i.Description,
			&i.Toc,
			&i.Recommendation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const gerSearchResult = `-- name: GerSearchResult :many
SELECT id, isbn, title, author, publisher, publication_year, set_isbn, volume, image_url, description, recommendation, toc, source, url, vector_search FROM Books
`

func (q *Queries) GerSearchResult(ctx context.Context) ([]Book, error) {
	rows, err := q.db.Query(ctx, gerSearchResult)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Isbn,
			&i.Title,
			&i.Author,
			&i.Publisher,
			&i.PublicationYear,
			&i.SetIsbn,
			&i.Volume,
			&i.ImageUrl,
			&i.Description,
			&i.Recommendation,
			&i.Toc,
			&i.Source,
			&i.Url,
			&i.VectorSearch,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookDetail = `-- name: GetBookDetail :one
SELECT 
    b.id, b.isbn, b.title, b.author, b.publisher, b.publication_year, b.set_isbn, b.volume, b.image_url, b.description, b.recommendation, b.toc, b.source, b.url, b.vector_search,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'libCode', l.lib_code,
            'classNum', l.class_num,
            'bookCode', l.book_code
        )
    ) AS lib_books
FROM Books b
JOIN libsbooks l 
    ON b.isbn = l.isbn AND l.lib_code = ANY($1::int[])
WHERE b.isbn = $2
GROUP BY b.isbn, b.id
`

type GetBookDetailParams struct {
	LibCodes []int32     `json:"libCodes"`
	Isbn     pgtype.Text `json:"isbn"`
}

type GetBookDetailRow struct {
	ID              int32       `json:"id"`
	Isbn            pgtype.Text `json:"isbn"`
	Title           pgtype.Text `json:"title"`
	Author          pgtype.Text `json:"author"`
	Publisher       pgtype.Text `json:"publisher"`
	PublicationYear pgtype.Text `json:"publicationYear"`
	SetIsbn         pgtype.Text `json:"setIsbn"`
	Volume          pgtype.Text `json:"volume"`
	ImageUrl        pgtype.Text `json:"imageUrl"`
	Description     pgtype.Text `json:"description"`
	Recommendation  pgtype.Text `json:"recommendation"`
	Toc             pgtype.Text `json:"toc"`
	Source          pgtype.Text `json:"source"`
	Url             pgtype.Text `json:"url"`
	VectorSearch    pgtype.Bool `json:"vectorSearch"`
	LibBooks        []byte      `json:"libBooks"`
}

func (q *Queries) GetBookDetail(ctx context.Context, arg GetBookDetailParams) (GetBookDetailRow, error) {
	row := q.db.QueryRow(ctx, getBookDetail, arg.LibCodes, arg.Isbn)
	var i GetBookDetailRow
	err := row.Scan(
		&i.ID,
		&i.Isbn,
		&i.Title,
		&i.Author,
		&i.Publisher,
		&i.PublicationYear,
		&i.SetIsbn,
		&i.Volume,
		&i.ImageUrl,
		&i.Description,
		&i.Recommendation,
		&i.Toc,
		&i.Source,
		&i.Url,
		&i.VectorSearch,
		&i.LibBooks,
	)
	return i, err
}

const getLibCodFromLibName = `-- name: GetLibCodFromLibName :one
SELECT lib_code FROM libraries WHERE lib_name = $1
`

func (q *Queries) GetLibCodFromLibName(ctx context.Context, libName pgtype.Text) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, getLibCodFromLibName, libName)
	var lib_code pgtype.Int4
	err := row.Scan(&lib_code)
	return lib_code, err
}

const searchFromBooks = `-- name: SearchFromBooks :many
SELECT id, isbn, title, author, publisher, publication_year, set_isbn, volume, image_url, description, recommendation, toc, source, url, vector_search 
FROM books
WHERE author LIKE '%' || $1 || '%' OR title LIKE '%' || $1 || '%'
ORDER BY ((bigm_similarity(author, $1) + bigm_similarity(title, $1)) * 10) DESC
LIMIT 50
`

func (q *Queries) SearchFromBooks(ctx context.Context, keyword pgtype.Text) ([]Book, error) {
	rows, err := q.db.Query(ctx, searchFromBooks, keyword)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Isbn,
			&i.Title,
			&i.Author,
			&i.Publisher,
			&i.PublicationYear,
			&i.SetIsbn,
			&i.Volume,
			&i.ImageUrl,
			&i.Description,
			&i.Recommendation,
			&i.Toc,
			&i.Source,
			&i.Url,
			&i.VectorSearch,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
